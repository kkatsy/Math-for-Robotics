import csv
import matplotlib.pyplot as plt
import numpy as np
from numpy.linalg import pinv, inv
from scipy.spatial import distance
from scipy.linalg import solve


def split(waypoints):
    x = []
    y = []

    for coordinates in waypoints:
        x.append(float(coordinates[0]))
        y.append(float(coordinates[1]))
    return x, y


def linear_interpolation(X, Y, div):
    # plot

    x1, y1, x2, y2 = 0, 0, 0, 0
    Y_approx = []
    errors = []
    for i in range(len(X) - 1):
        if i % div == 0:
            x1, y1 = X[i], Y[i]

            if i + div > len(X)or i == 2850:
                print(i)
                break

            x2, y2 = X[i+div], Y[i+div]
            x = np.array([x1, x2])
            if (x2 - x1) == 0:
                y = y1 + (x - x1) * 0
            else:
                y = y1 + (x - x1) * ((y2 - y1) / (x2 - x1))

            plt.plot(x, y, 'r')

        x_val = X[i]
        y_true = Y[i]

        if (x2 - x1) == 0:
            y_approx = float(y1 + (x_val - x1) * 0)
        else:
            y_approx = float(y1 + (x_val - x1) * ((y2 - y1) / (x2 - x1)))

        Y_approx.append(y_approx)
        the_error = abs(y_approx - y_true)
        errors.append(the_error)

    plt.show()

    overall_error = sum(errors)
    return overall_error


def quadratic_polynomial_interpolation(X, Y, div):
    # plot
    Y_approx = []
    errors = []
    x0, y0, x1, y1, x2, y2 = 0, 0, 0, 0, 0, 0
    for i in range(len(X)-1):
        if i % (div*2) == 0:
            if i + (2 * div) > len(X) or i == 2700:
                print(i)
                break
            x0, y0 = X[i], Y[i]
            x1, y1 = X[i + div], Y[i + div]
            x2, y2 = X[i + 2*div], Y[i + 2*div]

            y = np.asarray([y0, y1, y2])
            V = np.asarray([[1, x0, x0**2],[1, x1, x1**2],[1, x2, x2**2]])
            V_inv = pinv(V)
            A = np.dot(V_inv, y)

            x_plot = np.linspace(min(x0, x2), max(x0, x2),100)
            y_plot = A[0] + A[1] * x_plot + A[2] * x_plot**2

            plt.plot(x_plot, y_plot, 'g')

        x_val = X[i]
        y_true = Y[i]
        y_approx = A[0] + A[1] * x_val + A[2] * x_val**2
        Y_approx.append(y_approx)
        the_error = abs(y_approx - y_true)
        errors.append(the_error)

    plt.show()
    overall_error = sum(errors)
    return overall_error


def cubic_spline_interpolation_boop(X, Y, div):
    # plot
    Y_approx = []
    Y_approx = []
    errors = []
    x0, y0, x1, y1, x2, y2 = 0, 0, 0, 0, 0, 0
    for i in range(len(X) - 1):
        if i % (div * 2) == 0:
            if i + 2 * div > len(X):
                break
            x1, y1 = X[i], Y[i]
            x2, y2 = X[i + div], Y[i + div]
            x3, y3 = X[i + 2 * div], Y[i + 2 * div]

            b = np.array([y1, y2, y2, y3, 0, 0, 0, 0])
            b = b
            A = np.array([[x1**3, x1**2, x1, 1, 0, 0, 0, 0],
                          [0, 0, 0, 0, x2**3, x2**2, x2, 1],
                          [x2**2, x2**2, x2, 1, 0, 0, 0, 0],
                          [0, 0, 0, 0, x3**3, x3**2, x3, 1],
                          [3 * x2**2, 2 * x2, 1, 0, -3 * x2**2, -2 * x2, -1, 0],
                          [6 * x2, 2, 0, 0, -6 * x2, -2, 0, 0],
                          [6 * x1, 2, 0, 0, 0, 0, 0, 0],
                          [0, 0, 0, 0, 6 * x3, 2, 0, 0]])
            C = np.dot(inv(A), b)
            #C = solve(A, b)
            c_1, c_2 = np.array_split(C, 2)

            x_1 = np.linspace(min(x1, x2), max(x1, x2),50)
            x_2 = np.linspace(min(x2, x3), max(x2, x3),50)
            y_s1 = c_1[0]* x_1**3 + c_1[1]* x_1**2 + c_1[2]*x_1 + c_1[3]
            y_s2 = c_2[0]* x_2**3 + c_2[1]* x_2**2 + c_2[2]*x_2 + c_2[3]

            plt.plot(x_1, y_s1, 'b')
            plt.plot(x_2, y_s2, 'g')

        x_val = X[i]
        y_true = Y[i]

        interval_1 = sorted([x1,x2])
        interval_2 = sorted([x2, x3])
        if interval_1[0] <= x_val < interval_1[1]:
            y_approx = c_1[0] * x_val ** 3 + c_1[1] * x_val ** 2 + c_1[2] * x_val + c_1[3]
        elif interval_2[0] <= x_val <= interval_2[1]:
            y_approx = c_2[0] * x_val ** 3 + c_2[1] * x_val ** 2 + c_2[2] * x_val + c_2[3]

        Y_approx.append(y_approx)
        the_error = abs(y_approx - y_true)
        errors.append(the_error)
    plt.show()

    overall_error = sum(errors)
    return overall_error


def cubic_spline_interpolation(X, Y, div):
    # plot
    Y_approx = []
    Y_approx = []
    errors = []
    x0, y0, x1, y1, x2, y2 = 0, 0, 0, 0, 0, 0
    for i in range(len(X) - 1):
        if i % (div * 2) == 0:
            if i + 2 * div > len(X):
                break
            x1, y1 = X[i], Y[i]
            x2, y2 = X[i + div], Y[i + div]
            x3, y3 = X[i + 2 * div], Y[i + 2 * div]

            b = np.asarray([y1, y2, y2, y3, 0, 0, 0, 0]).reshape(8,1)
            A = np.asarray([[x1**3, x1**2, x1, 1, 0, 0, 0, 0],
                            [x2**3, x2**2, x2, 1, 0, 0, 0, 0],
                            [0, 0, 0, 0, x2**3, x2**2, x2, 1],
                            [0, 0, 0, 0, x3**3, x3**2, x3, 1],
                            [3*(x2**2), 2*x2, 1, 0, -3*(x2**2), -2*x2, -1, 0],
                            [6*x2, 2, 0, 0, -6*x2, -2, 0, 0],
                            [6*x1, 2, 0, 0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 6*x3, 2, 0, 0]])

            C = np.dot(pinv(A), b)
            c_1, c_2 = np.array_split(C, 2)

            x_1 = np.linspace(x1, x2, 50)
            x_2 = np.linspace(x2, x3, 50)
            y_s1 = c_1[0] * x_1 ** 3 + c_1[1] * x_1 ** 2 + c_1[2] * x_1 + c_1[3]
            y_s2 = c_2[0] * x_2 ** 3 + c_2[1] * x_2 ** 2 + c_2[2] * x_2 + c_2[3]

            plt.plot(x_1, y_s1, 'b')
            plt.plot(x_2, y_s2, 'g')

        x_val = X[i]
        y_true = Y[i]

        interval_1 = sorted([x1, x2])
        interval_2 = sorted([x2, x3])
        if interval_1[0] <= x_val < interval_1[1]:
            y_approx = c_1[0] * x_val ** 3 + c_1[1] * x_val ** 2 + c_1[2] * x_val + c_1[3]
        elif interval_2[0] <= x_val <= interval_2[1]:
            y_approx = c_2[0] * x_val ** 3 + c_2[1] * x_val ** 2 + c_2[2] * x_val + c_2[3]

        Y_approx.append(y_approx)
        the_error = abs(y_approx - y_true)
        errors.append(the_error)
    plt.show()

    overall_error = sum(errors)
    return overall_error


waypoints = []
with open('waypoints.csv', 'r') as file:
    file = csv.reader(file)
    for coordinates in file:
        waypoints.append((float(coordinates[0]), float(coordinates[1])))


# plt.plot(x, y)
# plt.scatter(x, y, s=2, c='r')
# plt.show()

# original - 2905
# 10Hz, 1Hz, and 0.2Hz
sample_10 = [point for i, point in enumerate(waypoints) if i%3 == 0]
sample_10_split = split(sample_10)

sample_1 = [point for i, point in enumerate(waypoints) if i%30 == 0]
sample_1_split = split(sample_1)

sample_0_2 = [point for i, point in enumerate(waypoints) if i%150 == 0]
sample_0_2_split = split(sample_0_2)

waypoints_split = split(waypoints)

# plt.scatter(sample_10_split[0], sample_10_split[1], s=2, c='r')
# plt.show()
#
# plt.scatter(sample_1_split[0], sample_1_split[1], s=2, c='r')
# plt.show()
#
# plt.scatter(sample_0_2_split[0], sample_0_2_split[1], s=2, c='r')
# plt.show()

error_10hz = quadratic_polynomial_interpolation(waypoints_split[0], waypoints_split[1], 3)
print("10hz error = ", error_10hz)
error_1hz = quadratic_polynomial_interpolation(waypoints_split[0], waypoints_split[1], 30)
print("1hz error = ", error_1hz)
error_0_2hz = quadratic_polynomial_interpolation(waypoints_split[0], waypoints_split[1], 150)
print("0.2hz error = ", error_0_2hz)



